# OK detect crs type (2 or 32)
# OK detect number of channels
read pulse counter BEFORE stop
multithreading transfer
check if Decode is not overlapped for different cbacks (threads?)

cnt_prev - check counter consistency
also use Counter and cnt for consistency check

Class - data, pulses etc...

Reset

# OK limits of parameters

# OK save/read parameters

check chan for each 2byte or 8byte data (crs2 or crs32)

# OKOK make flip-flop buffers for Bevents

# ??OK?? join all threads at exit

simulate too long pulse in readpulse2 (return 2)

make DoReset/greset() - detect crs, clear everything

# ?? set chanPresent for open files (no module)

make colors in crspardlg

# OK calculate data rate instantly (between subsequent buffers), not as integral

clean obsolete variables

write/read durWr[],preWr[] for each raw .gz file additionally to toptions
/or split toptions into two varibles:
opt1, opt2 - with fixed and non-fixed structures

implement dock/undock - see e.g. tutorials/eve

make different buf sizes for usb and readfile (now it's the same)

PulseClass::FindPeaks() -> check pileup part...

clean libmana->greset()

use blosc for compression

Event_Insert_Pulse: //add new event at the beginning of the eventlist:
-> should use m_event instead of Levents.begin() (??)

analyze rest of events after acq stop (s_flag=2, trd_ana->Run...)

initialize raw_write, dec_write to false, also after opening par file

avoid overwriting raw/dec files

31.01.18
check opt.Tstop for data acquisition

23.03.18
1. chanPresent=buf_in[3]*4; (libcrs.cpp) - как номеровать каналы, когда их два на плате?
2. Поправить пределы параметров для новой платы (например, M = 0…4093)
3. Поправить Command_crs (используется в crspardlg.cpp при изменении параметров при работающей acq)
4. Добавить задержку в параметры

